{
  parserClass="org.thymeleaf.extras.idea.lang.expression.parser.ThymeleafExpressionParser"
  parserUtilClass="org.thymeleaf.extras.idea.lang.expression.parser.ThymeleafExpressionParserUtil"

  psiPackage="org.thymeleaf.extras.idea.lang.expression.psi"
  psiImplPackage="org.thymeleaf.extras.idea.lang.expression.psi.impl"
  psiImplUtilClass="org.thymeleaf.extras.idea.lang.expression.psi.impl.ThymeleafExpressionPsiImplUtil"

  elementTypeHolderClass="org.thymeleaf.extras.idea.lang.expression.parser.ThymeleafExpressionElementTypes"
  elementTypeClass="org.thymeleaf.extras.idea.lang.expression.parser.ThymeleafExpressionCompositeElementType"
  tokenTypeClass="org.thymeleaf.extras.idea.lang.expression.parser.ThymeleafExpressionElementType"

  tokens=[
    VARIABLE_EXPR_START='${'
    SELECTION_EXPR_START='*{'
    MESSAGE_EXPR_START='#{'
    LINK_EXPR_START='@{'
    EXPRESSION_END='}'

    OP_CONDITIONAL='?'
    OP_COLON=':'
    OP_DEFAULT='?:'

    OP_MUL='*'
    OP_DIV='/'
    OP_REMAINDER='%'
    OP_PLUS='+'
    OP_MINUS='-'

    CONVERTED_VARIABLE_EXPR_START='${{'
    CONVERTED_SELECTION_EXPR_START='*{{'
    CONVERTED_EXPRESSION_END='}}'

    // comment='regexp:--.*'
    // The actual definition of token is a bit more complicated
    token='regexp:(.+)'
    string='regexp:([^\{\}\n]+)'
  ]

  name(".*expr")='expression'
  name(".*expression")='expression'

  // Note: When there are multiple extends("...") patterns applicable for the same rule,
  //       the first extends(...)-clause that matches takes precedence.
  //       Therefore, match-all patterns like ".*expr" have to come last.

  extends("(variable|selection|message|link)_expr")='generic_selection_expr'
  extends(".*expr")=expression

  methods("(variable|selection|message|link)_expr")=[
    getSelectionString="/string[0]"
  ]

  // Enable PsiReferenceContributor on all generic_selection_expr subtypes
  implements("generic_selection_expr")="com.intellij.psi.ContributedReferenceHost"
  methods("generic_selection_expr")=[getReferences]
}

root ::= expression

//
// the root expression rule
//
expression ::= conditional_group | add_group | mul_group | primary_group

///
// private rules to define operators with the same priority
//
private conditional_group ::= conditional_expr | default_expr
private mul_group ::= mul_expr | div_expr | remainder_expr
private add_group ::= plus_expr | minus_expr
private primary_group ::= token_expr | generic_selection_expr

//
// public rules for each expression
//
conditional_expr ::= expression '?' expression ':' expression
default_expr ::= expression '?:' expression
mul_expr ::= expression '*' expression
div_expr ::= expression '/' expression
remainder_expr ::= expression '%' expression
plus_expr ::= expression '+' expression
minus_expr ::= expression '-' expression

// Selectors: ${...}, *{...}, #{...} and @{...}
generic_selection_expr ::= variable_expr | selection_expr | link_expr | message_expr

variable_expr ::= converted_variable_expr | standard_variable_expr
selection_expr ::= converted_selection_expr | standard_selection_expr
message_expr ::= '#{' standard_expr_content '}' {pin=1}
link_expr ::= '@{' standard_expr_content '}' {pin=1}

private converted_variable_expr ::= '${{' converted_expr_content '}}' {pin=1}
private converted_selection_expr ::= '*{{' converted_expr_content '}}' {pin=1 recoverWhile=converted_expr_recover}
private converted_expr_content ::= string {recoverWhile=converted_expr_recover}
private converted_expr_recover ::= !('}}')

private standard_variable_expr ::= '${' standard_expr_content '}' {pin=1}
private standard_selection_expr ::= '*{' standard_expr_content '}' {pin=1}
private standard_expr_content ::= string {recoverWhile=standard_expr_recover}
private standard_expr_recover ::= !('}')

// Conditionals: (cond ? then : else) or also (cond ? then)
// conditional_expr ::=

// Text tokens: something
token_expr ::= token

// Text literals: 'something'
// text_literal_expr ::= "'" string "'" {pin=1}