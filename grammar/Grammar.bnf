{
  parserClass="org.thymeleaf.extras.idea.lang.expression.parser.ThymeleafExpressionParser"
  parserUtilClass="org.thymeleaf.extras.idea.lang.expression.parser.ThymeleafExpressionParserUtil"

  psiPackage="org.thymeleaf.extras.idea.lang.expression.psi"
  psiImplPackage="org.thymeleaf.extras.idea.lang.expression.psi.impl"
  psiImplUtilClass="org.thymeleaf.extras.idea.lang.expression.psi.impl.ThymeleafExpressionPsiImplUtil"

  elementTypeHolderClass="org.thymeleaf.extras.idea.lang.expression.parser.ThymeleafExpressionElementTypes"
  elementTypeClass="org.thymeleaf.extras.idea.lang.expression.parser.ThymeleafExpressionCompositeElementType"
  tokenTypeClass="org.thymeleaf.extras.idea.lang.expression.parser.ThymeleafExpressionElementType"

  tokens=[
    VARIABLE_EXPR_START='${'
    SELECTION_EXPR_START='*{'
    MESSAGE_EXPR_START='#{'
    LINK_EXPR_START='@{'
    EXPRESSION_END='}'

    CONVERTED_VARIABLE_EXPR_START='${{'
    CONVERTED_SELECTION_EXPR_START='*{{'
    CONVERTED_EXPRESSION_END='}}'

    // comment='regexp:--.*'
    string='regexp:([^\{\}\n]+)'
  ]

  name(".*expr")='expression'
  name(".*expression")='expression'

  // Note: When there are multiple extends("...") patterns applicable for the same rule,
  //       the first extends(...)-clause that matches takes precedence.
  //       Therefore, match-all patterns like ".*expr" have to come last.

  extends("(variable|selection|message|link)_expr")='generic_selection_expr'
  extends(".*expr")=expression

  methods("(variable|selection|message|link)_expr")=[
    getSelectionString="/string[0]"
  ]

  // Enable PsiReferenceContributor on all generic_selection_expr subtypes
  implements("generic_selection_expr")="com.intellij.psi.ContributedReferenceHost"
  methods("generic_selection_expr")=[getReferences]
}

root ::= expression

expression ::= token_expr | generic_selection_expr

// Selectors: ${...}, *{...}, #{...} and @{...}
generic_selection_expr ::= variable_expr | selection_expr | link_expr | message_expr {recoverUntil=selection_expr_recover}

variable_expr ::= converted_variable_expr | standard_variable_expr
selection_expr ::= converted_selection_expr | standard_selection_expr
message_expr ::= '#{' string '}' {pin=1}
link_expr ::= '@{' string '}' {pin=1}

private converted_variable_expr ::= '${{' string '}}' {pin=1 recoverWhile=converted_expr_recover}
private converted_selection_expr ::= '*{{' string '}}' {pin=1 recoverWhile=converted_expr_recover}
private converted_expr_recover ::= !('}}')

private standard_variable_expr ::= '${' string '}' {pin=1 recoverWhile=selection_expr_recover}
private standard_selection_expr ::= '*{' string '}' {pin=1 recoverWhile=selection_expr_recover}
private selection_expr_recover ::= !('}')

// Conditionals: (cond ? then : else) or also (cond ? then)
// conditional_expr ::=

// Text tokens: something
token_expr ::= string

// Text literals: 'something'
// text_literal_expr ::= "'" string "'" {pin=1}

//expr ::= factor plus_expr *
//left plus_expr ::= plus_op factor
//private plus_op ::= '+'|'-'
//private factor ::= primary mul_expr *
//left mul_expr  ::= mul_op primary
//private mul_op ::= '*'|'/'
//private primary ::= primary_inner factorial_expr ?
//left factorial_expr ::= '!'
//private primary_inner ::= literal_expr | ref_expr | paren_expr
//paren_expr ::= '(' expr ')' {pin=1}
//ref_expr ::= id
//literal_expr ::= number | string | float
